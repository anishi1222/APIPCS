# メソッド・マッピングポリシー

メソッド・マッピングを使うと、フロントエンドAPIとバックエンドサービスの差異を処理できます。すべてをゼロから設計する場合、メソッド・マッピングは不要かもしれませんが、ほとんどの場合は、1つ以上のバックエンドサービスが既に存在しています。APIが設計通りに動作するために、メソッド・マッピングポリシーを使用して、バックエンドサービスの差異を埋めることができます。

## 始める前に

1. 利用可能なAPI Platform Cloud Service環境を有している必要があります。API Platform Cloud Service環境の調達の詳細については、[環境](../../../../../environments/README.md)を参照してください。
1. チュートリアル[APIの作成](../../create_api)を完了しておく必要があります。
1. マイクロサービスの[ホスト](../../../../../docker/compose/ticketService/README.md#hosted-version)インスタンスを使用しているか、設定済みの[自分のインスタンス](../../../../../docker/compose/ticketService)のどちらが必要です。
1. サービスリクエストポリシーでサービスを使用するようにAPIを更新してある必要があります。

## クエリをリソースとして公開する

TicketServiceを提供するバックエンドサービスは、データ中心モデルゆえに、発信者がドキュメント構造に従ってクエリを発行するだけで、バックエンドデータのクエリを実行できるようになっています。

これを理解するために、クエリのアプローチを比較してみましょう。

### URLでの典型的なクエリ

[RFC3986](https://tools.ietf.org/html/rfc3986#section-3.4)では、URL内のクエリ文字列識別子として*?*を定義しています。

> 例：[GET] `http：//<host>:<port>/tickets?status=Unresolved`

ここでは、状態が*Unresolved*であるチケットの単純なGETリクエストを実行しています。URLで、*?*がクエリの開始を示します。典型的なクエリが*key=value*のペアです。複数のクエリがある場合、それらを*&*で区切ることができます。

もう一つの一般的な方法は、階層構造のクエリを提供するように、リソースを構築することです。例えば、`http://<host>:<port>/tickets/Resolved`や`http://<host>:<port>/tickets/Unresolved`のようなURLを使用します。ここでリソースは、フィルタリング条件を提供しています。

### マイクロサービスのクエリアプローチ

私たちのマイクロサービスは、単純に[Eve](python-eve.org)フレームワークを使用しています。このフレームワークを使うと、Python、Flask、MongoDBを使って堅牢なRESTサービスを作成できます。[Eve](python-eve.org)は、使用可能なクエリの種類を管理する素晴らしい機能があります。今回は演習目的のため、サービスの開発者はどのクエリに対してもオープンであると仮定しましょう。私たちもそれを変更しません。

さらに、[Eve](python-eve.org)には、APIコンシューマーを混乱させる可能性のあるクエリを指定する斬新な方法があります。

演習目的のために、APIのコンシューマは、URIに `/resolved`または`/unresolved`を追加してフィルタリングしますが、裏のマイクロサービスはこれを理解しません。

裏のマイクロサービスは、`http://<host>:<port>/tickets?where={"status":"Resolved"}`のようにURLにクエリを含めるだけで、任意のデータフィールドでフィルタリングできます。あなたはこれを見て無効なクエリだと言うかもしれません。しかし、これは確実に有効です。APIコンシューマーに提供する形ではないだけです。

## リソースをクエリに変換する

### API Platform Cloud Serviceにログイン

1. 選択した環境の説明に従って、ブラウザで管理ポータルのURLをアクセスします。

  > このURLは、選択した[環境](../../../../../environments/README.md)に基づいていますが、形式は `http(s)://<host>:<port>/apiplatform`です。

1. APIマネージャーロールを持つユーザーとしてログインします。

### APIの編集

1. *API*メニューが表示されていることを確認します。左上に*API*が表示され、右側に*作成*ボタンが表示されているはずです。みつからない場合は、左側のメニューボタンを選択し、*API*を選択してください。
1. 作成済みのAPIを検索します。
    1. APIのリストでAPIを見つけたら、API名をクリックして編集を続行します。
1. *使用可能なポリシー*の*インタフェース管理*グループを展開し、*メソッド・マッピング*ポリシーを選択します。

このポリシーでは2つの条件を追加します。

- 条件1：
  - API：
    - リソース： `resolved`
    - メソッド： `GET`
  - サービス：
    - リソース： `/`
    - メソッド： `同じ状態を維持`

*条件1*の*問合せパラメータ*を展開します。

*サービス*の下でパラメータを`where={"status":"Resolved"}`に設定します。API側を空白のままにしておきます。

2番目の条件を追加します。上記のパターンに従って、APIが`unresolved`のリソースを受け取るたびに、 `Unresolved`のチケットをクエリするための第2の条件を設定します。

*適用*をクリックします。

APIを保存してからデプロイ（または再デプロイ）します。 APIのデプロイに関する復習が必要な場合は、[APIのデプロイ](../../deploy_api)にアクセスしてください。

## 結論

このチュートリアルでは、以下の方法を学習しました。

- メソッド・マッピングポリシーを使用して、バックエンドサービス固有要件を処理します。
